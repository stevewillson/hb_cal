<% //debugger %>
<%

function drawHeaderRow (calStartDate, calEndDate, cellWidth) {
  // assign the day values of the weekday to print them on the table header
  const weekday = ['S', 'M', 'T', 'W', 'T', 'F', 'S']

  let headerRow = ''
  headerRow += '<tr>\n'
  headerRow += '<th class="hb_header" data-category="top column" style="width: ' + (cellWidth * 2) + 'px;">\n'
  headerRow += 'Category\n'
  headerRow += '</th>\n'

  // draw additional columns, will be end date - start date columns wide
  for (let m = new Moment(calStartDate).startOf('days'); m.diff(calEndDate, 'days') <= 0; m.add(1, 'days')) {
    // for the header row, display the date number and the day of the week
    const d = m.date()
    const n = weekday[m.day()]
    const curDay = Moment().startOf('days')

    // highlight the current day in the top
    let cellStyle = ''
    if (m.isSame(curDay, 'days')) {
      cellStyle += 'background-color: #AAAAAA;'
    }
    headerRow += '<th class="hb_header" data-date="' + m.format('YYYY-MM-DD') + '" style="width: ' + cellWidth + 'px; ' + cellStyle + '">\n'
    headerRow += d + ' ' + n + '\n'
    headerRow += '</th>\n'
  }

  headerRow += '</tr>'
  return headerRow
}

/* 
 * draw a category row for the hb table, this will request the events from the database
 * @ param rowName {string} - rowName the name of the row to be drawn
 */
function drawCategoryRow (rowName) {
  // add the left most cell, this is the event category
  let categoryRow = ''
  const curDay = new Moment().startOf('days')
  categoryRow += '<tr id="' + rowName + '" data-resource-id="' + rowName + '" style="height: 30px; border: 1px solid black;" >'
  categoryRow += '<td style="width: ' + (cellWidth * 2) + 'px; border: 1px solid black;">\n'
  categoryRow += rowName
  categoryRow += '</td>\n'

  for (var m = new Moment(calStartDate).startOf('days'); m.diff(calEndDate, 'days') <= 0; m.add(1, 'days')) {
    let cellStyle = ''
    if (m.isSame(curDay, 'day')) {
      cellStyle += 'background-color: #AAAAAA;'
    }
    // write a cell and move on
    categoryRow += '<td colspan="1" id="' + m.format('YYYY-MM-DD') + '-' + rowName + '" style="width: ' + cellWidth + 'px; ' + cellStyle + '; border: 1px solid black;">\n'
    categoryRow += '</td>\n'
  }
  // done with the m day iteration, add ending values to the row and then return the row value
  categoryRow += '</tr>\n'
  return categoryRow
}

function drawCalendar (calStartDate, calEndDate, cellWidth, categoryRows) {
  const tableWidth = cellWidth * (calEndDate.diff(calStartDate, 'days') + 3)
  let cal = '<div id="hbCal" class="hbCal">\n'
  cal += '<table id="hbOuterTable" class="hbTable" style="width: ' + tableWidth + 'px; table-layout: fixed; border: 1px solid black;">\n'

  // add the header row in here
  cal += drawHeaderRow(calStartDate, calEndDate, cellWidth)

  // loop through the categories to add a row for each category on the table, use the 'drawCategoryRow' function to add a row to the html table
  for (let i = 0; i < categoryRows.length; i++) {
    cal += drawCategoryRow(categoryRows[i])
  }
  cal += '</table>\n'
  cal += '</div>\n'
  return cal
}

// START OF SCRIPT EXECUTION
// check for cookie values to set an arbitrary start date, stop date, and cell_width
try {
  var calStartDate = new Moment(calView.startDate).startOf('day')
  if (!calStartDate.isValid()) throw new Error('Invalid Date: calStartDate')
  if (calView.startDate === undefined) throw new Error('startDate undefined')
} catch (err) {
  calStartDate = new Moment().startOf('day')
}

try {
  var calEndDate = new Moment(calView.endDate).startOf('day')
  if (!calEndDate.isValid()) throw new Error('Invalid Date: calEndDate')
  if (calView.endDate === undefined) throw new Error('endDate undefined')
  if (calEndDate.isSame(calStartDate)) throw new Error('endDate same as startDate')
} catch (err) {
  calEndDate = calStartDate.clone().add(30, 'days')
}

try {
  var cellWidth = calView.cellWidth
  if (cellWidth === undefined) throw new Error('cellWidth is undefined')
  if (isNaN(cellWidth)) throw new Error('cellWidth is NaN')
  if (cellWidth === '') throw new Error('cell_width is empty')
} catch (err) {
  cellWidth = 50
}

let categoryRows = []

// iterate through all of the events and add the category to the categoryRows array, only add 1 entry per category
for (var i = 0; i < events.events.length; i++) {
  const curEventCategory = events.events[i].eventCategory
  if (!categoryRows.includes(curEventCategory)) {
    categoryRows.push(curEventCategory)
  }
}
// need to pass an array of the rows to draw, should be deduplicated
var hbCalTable = drawCalendar(calStartDate, calEndDate, cellWidth, categoryRows)
%>
<script>

// TODO move to generate the calendar client side so there is only 1 request to the api/event endpoint
// if I generate the calendar after the api request, now move to add more functionality, can I resize the event columns to accomodate the events?

// get the events from the event api, add them to the calendar by specifying the location of the visible cells
let requestURL = 'http://localhost:3000/api/event'
let request = new XMLHttpRequest()
request.open('GET', requestURL)
request.responseType = 'json'
//request.send()

// layoutArea will be an array that contains tuples of areas that are currently occupied on the screen, it will be the upper left corner of the box
// for multiday events, the upper left corner of that cell will be added to the array
var layoutArea = []

function addEvent (startDate, endDate, name, category, id, layoutArea) {
  // get the location of the start and the location of the end
  try {
    var elmnt = document.getElementById(startDate + '-' + category)
    var elmntWidth = elmnt.style.width
    if (elmnt === null) throw new Error('elmnt is null')
  } catch (err) {
    // the start of the event is not in the view window
    // console.log('Cannot access the event: ' + err)
    return;
  }
  const event = document.createElement('div')
  const hbCal = document.getElementById('hbCal')
  const hbCalOffsetTop = hbCal.offsetTop
  const hbCalOffsetLeft = hbCal.offsetLeft

  event.style.position = 'absolute'
  event.style.border = '1px solid black'
  event.style.textAlign = 'center'

  // add 5px to the top to offset the cell from the top border
  let topLocation = hbCalOffsetTop + elmnt.offsetTop + 5

  let leftLocation = hbCalOffsetLeft + elmnt.offsetLeft + 2
  event.style.top = topLocation + 'px'
  event.style.left = leftLocation + 'px'

  // prior to drawing the events, sort them by the category..., alphabetically

  // check if the layoutArea includes the particular place to draw this item
  for ( var i = 0; i < layoutArea.length; i++) {
    if (leftLocation === layoutArea[i].left && topLocation === layoutArea[i].top) {
      // the box will be drawn where a square already exists 
      // add a rowHeight value to the row
      // get the current 
      categoryRow = document.getElementById(category)
      // get the current height, if "" then set to 60
      categoryRowHeight = parseInt(categoryRow.style.height, 10)
      if (isNaN(categoryRowHeight)) {
        // there are two events that need to occupy this row now
        categoryRowHeight = 60
      } else {
        // there are more than two events that need to occupy this row
        categoryRowHeight += 30
      }
      categoryRow.style.height = categoryRowHeight + 'px'
      topLocation += 30
      event.style.top = topLocation + 'px'
    }
  }
  layoutArea.push({ left: leftLocation, top: topLocation })

  let eventTextContent = ''
  eventTextContent += '<form name="delevent" method="post" action="./delevent"><input type="hidden" name="documentid" '
  eventTextContent += 'value="' + id + '"><button class="linkButton" type="submit">'
  eventTextContent += name
  eventTextContent += '</button></form>\n'

  event.innerHTML = eventTextContent

  // make the width of the box until the end of the event, also check to see if the event goes over the edge of the calendar

  // get the endDate of the cell, or if the endDate is null the last date of the calendar
  let cellWidth = ''

  // determine if the end cell is on the display area, if not, determine the farthest right offset for the row and then draw the cell to that right end
  try {
    const endElmnt = document.getElementById(endDate + '-' + category)
    if (endElmnt === null) throw new Error('endElmnt is null')
    // make the width the cell width plus the difference between the left offset of the first cell to the left offset of the second cell
    cellWidth = endElmnt.offsetLeft - elmnt.offsetLeft + parseInt(elmnt.style.width, 10) - 5
  } catch (err) {
    // the end of the event is not in the view window
    let hbOuterTable = document.getElementById('hbOuterTable')
    const hbOuterTableWidth = parseInt(hbOuterTable.style.width, 10)
    cellWidth = hbOuterTableWidth - elmnt.offsetLeft - 2
    // console.log('Cannot access the event: ' + err)
  }
  // add values for the cellWidth to the array, take each cellWidth and add multiples of that to the layoutArea
  event.style.width = cellWidth + 'px'
  let finalLeftPosition = leftLocation + cellWidth
  for (var layoutIter = leftLocation; layoutIter < finalLeftPosition; layoutIter += parseInt(elmntWidth, 10)) {
    layoutArea.push({ left: layoutIter, top: topLocation })
  }
  hbCal.appendChild(event)
}

window.onload = function() {
  request.send()
  request.onload = function() {
    // loop through the events here to add them to the calendar
    var events = request.response
    for ( let i = 0; i < events.events.length; i++) {
      // console.log(events)
      let eventStartDate = events.events[i].eventStartDate
      let eventEndDate = events.events[i].eventEndDate
      let eventSummary = events.events[i].eventSummary
      let eventCategory = events.events[i].eventCategory
      let eventId = events.events[i]._id
      addEvent(eventStartDate, eventEndDate, eventSummary, eventCategory, eventId, layoutArea)
    }
  }
}

</script>
<%- hbCalTable %>
