<% //debugger %>
<%

function drawHeaderRow (calStartDate, calEndDate, cellWidth) {
  // assign the day values of the weekday to print them on the table header
  const weekday = ['S', 'M', 'T', 'W', 'T', 'F', 'S']

  let headerRow = ''
  headerRow += '<tr>'
  headerRow += '<th class="hb_header" data-category="top column" style="width: ' + (cellWidth * 2) + 'px;">\n'
  headerRow += 'Category\n'
  headerRow += '</th>\n'

  // draw additional columns, will be end date - start date columns wide
  for (let m = new Moment(calStartDate).startOf('days'); m.diff(calEndDate, 'days') <= 0; m.add(1, 'days')) {
    // for the header row, display the date number and the day of the week
    const d = m.date()
    const n = weekday[m.day()]
    const curDay = Moment().startOf('days')

    // highlight the current day in the top
    let cellStyle = ''
    if (m.isSame(curDay, 'days')) {
      cellStyle += 'background-color: #AAAAAA;'
    }

    headerRow += '<th class="hb_header" data-date="' + m.format('YYYY-MM-DD') + '" style="width: ' + cellWidth + 'px; ' + cellStyle + '">\n'
    headerRow += d + ' ' + n + '\n'
    headerRow += '</th>\n'
  }

  headerRow += '</tr>'
  return headerRow
}

function drawCategoryRow (rowName) {
  // add the left most cell, this is the event category
  let categoryRow = ''
  const curDay = new Moment().startOf('days')
  categoryRow += '<tr id="' + rowName + '" data-resource-id="' + rowName + '" style="30px;" >'
  categoryRow += '<td style="width: ' + (cellWidth * 2) + 'px;">\n'
  categoryRow += rowName
  categoryRow += '</td>\n'

  for (var m = new Moment(calStartDate).startOf('days'); m.diff(calEndDate, 'days') <= 0; m.add(1, 'days')) {
    let cellStyle = ''
    if (m.isSame(curDay, 'day')) {
      cellStyle += 'background-color: #AAAAAA;'
    }
    // write a cell and move on
    categoryRow += '<td colspan="1" id="' + m.format('YYYY-MM-DD') + '-' + rowName + '" style="width: ' + cellWidth + 'px; ' + cellStyle + '">\n'
    categoryRow += '</td>\n'
  }
  // done with the m day iteration, add ending values to the row and then return the row value
  categoryRow += '</tr>\n'
  return categoryRow
}

function drawCalendar (calStartDate, calEndDate, cellWidth) {
  const tableWidth = cellWidth * (calEndDate.diff(calStartDate, 'days') + 3)

  let cal = '<div id="hbCal" class="hbCal">\n'
  cal += '<table id="hbOuterTable" class="hbTable" style="width: ' + tableWidth + 'px; table-layout: fixed; border: 1px solid black;">\n'

  // add the header row in here
  cal += drawHeaderRow(calStartDate, calEndDate, cellWidth)

  // make a new row to for each event category
  cal += '<tr>\n'
  const tableEventCategories = []

  // loop through the categories to add a row for each category on the table, use the 'drawCategoryRow' function to add a row to the html table
  for (let catIter = 0; catIter < hbEvents[0].length; catIter++) {
    const curEventCategory = hbEvents[0][catIter].eventCategory
    if (!tableEventCategories.includes(curEventCategory)) {
      tableEventCategories.push(curEventCategory)
      cal += drawCategoryRow(curEventCategory)
    }
  }
  cal += '</tr>\n'
  cal += '</table>\n'
  cal += '</div>\n'
  return cal
}

// START OF SCRIPT EXECUTION
// check for cookie values to set an arbitrary start date, stop date, and cell_width
try {
  var calStartDate = new Moment(calView.startDate).startOf('day')
  if (!calStartDate.isValid()) throw new Error('Invalid Date: calStartDate')
  if (calView.startDate === undefined) throw new Error('startDate undefined')
} catch (err) {
  calStartDate = new Moment().startOf('day')
}

try {
  var calEndDate = new Moment(calView.endDate).startOf('day')
  if (!calEndDate.isValid()) throw new Error('Invalid Date: calEndDate')
  if (calView.endDate === undefined) throw new Error('endDate undefined')
  if (calEndDate.isSame(calStartDate)) throw new Error('endDate same as startDate')
} catch (err) {
  calEndDate = calStartDate.clone().add(30, 'days')
}

try {
  var cellWidth = calView.cellWidth
  if (cellWidth === undefined) throw new Error('cellWidth is undefined')
  if (isNaN(cellWidth)) throw new Error('cellWidth is NaN')
  if (cellWidth === '') throw new Error('cell_width is empty')
} catch (err) {
  cellWidth = 50
}

// is this code necessary? not drawing events server side, currently just rendering the rows serverside, and that isn't necessary...
let curCat = ''
let prevCat = ''
let hbCatIndex = 0
// make an array of the events that are passed, group the events by category
let hbEvents = []
hbEvents[hbCatIndex] = []

// events are retrieved from the database in category and then date order
// this is no longer the case, the events are not necessarily stored in this way
// iterate through all of the events and put them in the array
for (var i = 0; i < events.events.length; i++) {
  curCat = events.events[i].category

  // check if the categories are different AND the iterator is not the first event, then make a new row
  if (curCat !== prevCat && i !== 0) {
    hbCatIndex++
    hbEvents[hbCatIndex] = []
  }

  hbEvents[hbCatIndex].push(events.events[i])

  // at the end of the loop, update prev_cat with the value of cur_cat
  prevCat = curCat
  
  // separate out the drawing from the event adding, populate the calendar by doing a request from the client
  var hbCalTable = drawCalendar(calStartDate, calEndDate, cellWidth)
}

%>
<script>

// TODO move to generate the calendar client side so there is only 1 request to the api/event endpoint
// if I generate the calendar after the api request, now move to add more functionality, can I resize the event columns to accomodate the events?

// get the events from the event api, add them to the calendar by specifying the location of the visible cells
let requestURL = 'http://localhost:3000/api/event'
let request = new XMLHttpRequest()
request.open('GET', requestURL)
request.responseType = 'json'
//request.send()

// layoutArea will be an array that contains tuples of areas that are currently occupied on the screen, it will be the upper left corner of the box
// for multiday events, the upper left corner of that cell will be added to the array
var layoutArea = []

function addEvent (startDate, endDate, name, category, id, layoutArea) {
  // get the location of the start and the location of the end
  try {
    var elmnt = document.getElementById(startDate + '-' + category)
    var elmntWidth = elmnt.style.width
    console.log('elmnt cell width is ' + elmntWidth)
    if (elmnt === null) throw new Error('elmnt is null')
  } catch (err) {
    // the start of the event is not in the view window
    // console.log('Cannot access the event: ' + err)
    return;
  }
  let event = document.createElement('div')
  let hbCal = document.getElementById('hbCal')
  let hbCalOffsetTop = hbCal.offsetTop
  let hbCalOffsetLeft = hbCal.offsetLeft

  event.style.position = 'absolute'
  event.style.border = '1px solid black'
  event.style.textAlign = 'center'

  let topLocation = hbCalOffsetTop + elmnt.offsetTop 

  let leftLocation = hbCalOffsetLeft + elmnt.offsetLeft
  event.style.top = topLocation + 'px'
  event.style.left = leftLocation + 'px'

  // prior to drawing the events, sort them by the category..., alphabetically

  // check if the layoutArea includes the particular place to draw this item
  for ( var i = 0; i < layoutArea.length; i++) {
    if (leftLocation === layoutArea[i].left && topLocation === layoutArea[i].top) {
      // the box will be drawn where a square already exists 
      // add a rowHeight value to the row
      // get the current 
      categoryRow = document.getElementById(category)
      // get the current height, if "" then set to 60
      categoryRowHeight = parseInt(categoryRow.style.height, 10)
      if (isNaN(categoryRowHeight)) {
        // there are two events that need to occupy this row now
        categoryRowHeight = 60
      } else {
        // there are more than two events that need to occupy this row
        categoryRowHeight += 30
      }
      categoryRow.style.height = categoryRowHeight + 'px'
      topLocation += 30
      event.style.top = topLocation + 'px'
    }
  }
  layoutArea.push({ left: leftLocation, top: topLocation })
  // console.log(layoutArea)

  let eventTextContent = ''
  eventTextContent += '<form name="delevent" method="post" action="./delevent"><input type="hidden" name="documentid" '
  eventTextContent += 'value="' + id + '"><button class="linkButton" type="submit">'
  eventTextContent += name
  eventTextContent += '</button></form>\n'

  event.innerHTML = eventTextContent

  // make the width of the box until the end of the event, also check to see if the event goes over the edge of the calendar

  // get the endDate of the cell, or if the endDate is null the last date of the calendar
  var cellWidth = ''

  try {
    var endElmnt = document.getElementById(endDate + '-' + category)
    if (endElmnt === null) throw new Error('endElmnt is null')
    // make the width the cell width plus the difference between the left offset of the first cell to the left offset of the second cell
    cellWidth = endElmnt.offsetLeft - elmnt.offsetLeft + parseInt(elmnt.style.width, 10) 
  } catch (err) {
    let hbOuterTable = document.getElementById('hbOuterTable')
    // need to set the cellWidth to the proper amount. - TODO
    cellWidth = parseInt(hbOuterTable.style.width, 10) - hbOuterTable.style.offsetLeft - elmnt.offsetLeft + parseInt(elmnt.style.width, 10)
    // TODO set the end of the event to the last cell in the table
    // the end of the event is not in the view window
    // console.log('Cannot access the event: ' + err)
    // return;
  }
  // add values for the cellWidth to the array, take each cellWidth and add multiples of that to the layoutArea
  event.style.width = cellWidth + 'px'
  let finalLeftPosition = leftLocation + cellWidth
  for (var layoutIter = leftLocation; layoutIter < finalLeftPosition; layoutIter += parseInt(elmntWidth, 10) + 2) {
    console.log('layoutIter is: ' + layoutIter)
    layoutArea.push({ left: layoutIter, top: topLocation })
  }

  hbCal.appendChild(event)
}

window.onload = function() {
  request.send()
  request.onload = function() {
    // loop through the events here to add them to the calendar
    var events = request.response
    for ( let i = 0; i < events.events.length; i++) {
      // console.log(events)
      let eventStartDate = events.events[i].eventStartDate
      let eventEndDate = events.events[i].eventEndDate
      let eventSummary = events.events[i].eventSummary
      let eventCategory = events.events[i].eventCategory
      let eventId = events.events[i]._id
      addEvent(eventStartDate, eventEndDate, eventSummary, eventCategory, eventId, layoutArea)
    }
  }
}

</script>
<%- hbCalTable %>


